## Welcome to GitHub Pages

You can use the [editor on GitHub](https://github.com/senathan/resume/edit/master/README.md) to maintain and preview the content for your website in Markdown files.

Whenever you commit to this repository, GitHub Pages will run [Jekyll](https://jekyllrb.com/) to rebuild the pages in your site, from the content in your Markdown files.

### Markdown

Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for

```markdown
Syntax highlighted code block

# Header 1
## Header 2
### Header 3

- Bulleted
- List

1. Numbered
2. List

**Bold** and _Italic_ and `Code` text

[Link](url) and ![Image](src)
```

import argparse
import requests
from requests.auth import HTTPBasicAuth
import json
import sys

# --- Step 1: Parse CLI args ---
parser = argparse.ArgumentParser()
parser.add_argument('--jira_link', required=True)
parser.add_argument('--project_key', required=True)
parser.add_argument('--user', required=True)
parser.add_argument('--api_token', required=True)
parser.add_argument('--summary', default='')
parser.add_argument('--description', default='')
args = parser.parse_args()

# --- Step 2: Default field values (fallbacks) ---
default_values = {
    "summary": args.summary.strip() or "Automated Dependency Upgrade - Evergreen Pipeline",
    "description": args.description.strip() or (
        "This ticket was generated by the Evergreen pipeline to track automated dependency upgrades."
    )
}

# --- Step 3: Setup Jira Auth and Headers ---
auth = HTTPBasicAuth(args.user, args.api_token)
headers = {
    "Accept": "application/json",
    "Content-Type": "application/json"
}

# --- Step 4: Fetch metadata to determine required fields ---
meta_url = f"{args.jira_link}/rest/api/2/issue/createmeta"
params = {
    "projectKeys": args.project_key,
    "expand": "projects.issuetypes.fields"
}
resp = requests.get(meta_url, headers=headers, auth=auth, params=params)

if resp.status_code != 200:
    print(f"❌ Failed to fetch createmeta: {resp.status_code}")
    print(resp.text)
    sys.exit(1)

try:
    issue_type_info = resp.json()['projects'][0]['issuetypes'][0]  # Default to first issue type
    issue_type_id = issue_type_info['id']
    fields = issue_type_info['fields']
except (IndexError, KeyError):
    print("❌ Couldn't extract issue type or fields from createmeta response.")
    sys.exit(1)

# --- Step 5: Build payload dynamically based on required fields ---
payload_fields = {
    "project": {"key": args.project_key},
    "issuetype": {"id": issue_type_id}
}

for field_key, field_info in fields.items():
    if field_info.get("required", False):
        field_type = field_info.get("schema", {}).get("type")
        print(f"⚙️ Required field: {field_key} (type: {field_type})")

        # Handle text fields only for now
        if field_key in default_values:
            payload_fields[field_key] = default_values[field_key]
        elif field_type in ["string", "text"]:
            payload_fields[field_key] = f"Auto-filled value for {field_key}"
        else:
            print(f"⚠️ Skipping unsupported required field: {field_key} ({field_type})")

# --- Step 6: Create Jira issue ---
create_url = f"{args.jira_link}/rest/api/2/issue"
create_payload = {"fields": payload_fields}

create_resp = requests.post(create_url, headers=headers, auth=auth, data=json.dumps(create_payload))

if create_resp.status_code == 201:
    issue_key = create_resp.json().get("key")
    print(f"✅ Jira ticket created: {issue_key}")
    print(f"{args.jira_link}/browse/{issue_key}")
else:
    print(f"❌ Failed to create Jira ticket: {create_resp.status_code}")
    print(create_resp.text)
    sys.exit(1)
